---
title: Without Flakes
description: Using flake-aspects with lib.evalModules and new-scope.
---

import { Aside } from '@astrojs/starlight/components';

## `new-scope` — named aspect namespaces

[`new-scope`](https://github.com/vic/flake-aspects/blob/main/nix/new-scope.nix) creates an isolated aspect namespace within any `lib.evalModules` evaluation:

```nix
let
  result = lib.evalModules {
    modules = [
      (new-scope "my")
      {
        my.aspects = { aspects, ... }: {
          laptop = {
            nixos = { pkgs, ... }: { environment.systemPackages = [ pkgs.vim ]; };
            includes = [ aspects.base ];
          };
          base.nixos = { lib, ... }: { networking.hostName = "laptop"; };
        };
      }
    ];
  };
in
  lib.nixosSystem { modules = [ result.config.my.modules.nixos.laptop ]; }
```

`new-scope "my"` creates:
- `my.aspects` — input: aspect definitions (type: `aspectsType`)
- `my.modules` — output: transposed + resolved modules (read-only)

<Aside>
  Test: [`without_flakes.nix`](https://github.com/vic/flake-aspects/blob/main/checkmate/modules/tests/without_flakes.nix)
</Aside>

## Multiple scopes

Independent scopes can coexist and merge. Each creates its own `<name>.aspects` / `<name>.modules` pair:

```nix
modules = [
  (new-scope "foo")
  (new-scope "bar")
  { foo.aspects.a.nixos.x = [ "from-foo" ]; }
  { bar.aspects.a.nixos.x = [ "from-bar" ]; }
  ({ config, ... }: { bar = config.foo; })  # merge foo into bar
];
```

After merging, `bar.modules.nixos.a` contains both `"from-foo"` and `"from-bar"`.

<Aside>
  Test: [`aspect_assignment.nix`](https://github.com/vic/flake-aspects/blob/main/checkmate/modules/tests/aspect_assignment.nix)
</Aside>

## `new` — low-level factory

[`new`](https://github.com/vic/flake-aspects/blob/main/nix/new.nix) is the callback-based primitive underneath `new-scope`:

```nix
new (option: transposed: {
  options.myLib.aspects = option;
  config.myLib.modules = transposed;
}) config.myLib.aspects
```

`new-scope` is sugar for the common `${name}.aspects` / `${name}.modules` pattern. Use `new` directly when you need custom option paths or additional logic in the callback.

Useful for libraries that want isolated aspect scopes or flake-parts independence (see [Den's scope](https://github.com/vic/den/blob/main/nix/scope.nix)).
